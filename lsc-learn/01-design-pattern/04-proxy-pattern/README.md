## 代理模式
    静态代理
    没什么说的
    
    动态代理
    JDK代理
    直接重新生成一套class字节码
    JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理 的目的。
    JDK Proxy 生成对象的步骤如下： 
    1、拿到被代理对象的引用，并且获取到它的所有的接口，反射获取。 
    2、JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。
    3、动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用。 
    4、编译新生成的 Java 代码.class。 
    5、再重新加载到 JVM 中运行。
    
    CGLib代理
    CGLib 动态代理执行代理方法效率之所以比 JDK 的高是因为 Cglib 采用了 FastClass 机 制，
    它的原理简单来说就是：为代理类和被代理类各生成一个 Class，
    这个 Class 会为代理类或被代理类的方法分配一个 index(int 类型)。
    这个 index 当做一个入参，FastClass 就可以直接定位要调用的方法直接进行调用，
    这样省去了反射调用，
    所以调用效率比 JDK动态代理通过反射调用高。
    
    
    对比 
    1.JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。 
    2.JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。 
    3.JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法， CGLib 执行效率更高。
    4.JDK生成class效率高, CGLib执行效率高, 两种代理方式spring都用了
    5.当需要被代理的类实现有接口的时候spring使用jdk代理, 没有实现接口的时候选择CGLib
    6.为什么jdk的生成效率高, CGLib执行效率高？ JDK生成一个新的类，通过发射进行调用;
    CGLib会对代理类和被代理类各生成一个class，调用的时候不需要通过反射进行调用。